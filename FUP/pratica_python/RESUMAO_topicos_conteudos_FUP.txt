APRESENTAÇÃO DA DISCIPLINA

INÍCIO
	* algoritmo
	* pseudo-código
	* python
	* variáveis
		- nomes de variáveis
		- case sensitive
		- palavras reservadas
		- tipos
			. números (inteiros[int,long], ponto flutuante [float], complex)
			. booleanos (True e False)
			. strings
			. listas
			. casting
	* atribuição (=)
	* operadores matemáticos (+ - * / ** %)
		- precedência
		- divisão de inteiros
		- concatenação (+ e *)
		- incrementação e decremento
	* operadores relacionais (== != < > >= <=)
	* operadores lógicos (and or not)
	* comentários (""" # )

	PROBLEMAS URI
		1002
		1009
		1012
		1014
		1020

ESTRUTURAS DE DECISÃO
	* O que é uma estrutura de condição ou de decisão? 
	* expressões booleanas
	* operadores relacionais ( == != > < >= <= )
	* LEMBRAR DE FALAR DA IDENTAÇÃO
	* SE
		- exemplos do cotidiano
			. se tenho dinheiro pro RU
			. se tenho tempo pra pegar o onibus
	* SENÃO
		- se não tenho dinheiro pro RU
	* SENÃO SE
	* EXERCICIOS
		- par ou ímpar
		- pedra, papel, tesoura
		- incremento do anterior: pedra, papel, tesoura, lagarto e spock
	* operadores lógicos (and, or, not)
	* EXERCÍCIOS
		- pedra, papel, tesoura com operadores lógicos
		- média do aluno
		- signo
		- moodle
		- URI
			. 1046
			. 1045
			. 1035
			. 1037
			. 1038

ESTRUTURAS DE REPETIÇÃO
	* até agora vimos comandos de forma linear
	* estruturas de decisão
	* as vezes precisamos executar um bloco de comandos várias vezes pra obter o resultado esperado
	* ex:
		- escreva um algoritmos que imprima os números de 1 a 10.
		- agora de 1 a 100.
		- agora de 1 a 1000.
		- agora de 1 a 10 elevado a 500.
	* na programação, a repetição é comum
	* utilizamos estruturas de repetição
	* chamamos de laços (ou loops)
	* chamamos de iteração a cada repetição do laço
	* o que será repetido é o que estiver em seu escopo
	* laços condicionais e contados
	* condicionais
		- também conhecidos como laços indefinidos
		- não se conhece previamente o número de repetições
		- é repetido ENQUANTO uma condição for satisfeita
		- ex: apagar a louça enquanto estiver suja
		- exemplo do fluxo
		- while
			. similar ao if (condição que controla)
			. variáveis de iteração (em geral são números)
	* contados
		- primeiramente, um pouco de listas
		- também conhecidos como laços definidos
		- temos conhecimento prévio de quantas repetições
		- ex: imprimir os números de 1 a 1000
		- for
			. for i in [5, 4, 3, 2, 1] :
				print(i)
				#i nesse caso é a variável de iteração
			. friends = ['Fulano', 'Cicrano', 'Cirano']
			  for friend in friends :
			  	print("Feliz ano novo "+friend);
			  	#friend é a variável de iteração
			. escopo é executado uma única vez pra cada valor da variável de iteração
	* encontrando o maior elemento [3, 41, 12, 9, 74, 15]
	* contando as iterações
	* acumulando o valor
	* buscando por um elemento
	* comando break e continue

FUNÇÕES
	* funções: analogia com um serviço de terceiros
		- empresa passa para os terceiros o que eles necessitam para prestar um serviço (parâmetros)
		- terceiros realizam e devolvem os serviços ou produtos para a empresa (retorno)
	* função
		- sequência de instruções agrupadas
			. quantidade limitada
			. qualquer tipo de instrução
			. recebem parâmetros
			. retornam algo (ou não)
		- utilizada para organizar o programa em pequenos pedaços
	* funções em python
		- da linguagem (built-in)
		- definidas pelo programador
		- palavra reservada "def" (abreviação de definition, definição, em português)
		- chamamos a função usando seu nome e os parâmetros
		- def <nome_da_funcao>(<par1>, <par2>, ..., <parN>) : #seguido do escopo, que tem ou não um retorno
		- a função não é executada sozinha, automaticamente. No entanto, uma vez definida, podemos chamá-la quantas vezes quisermos.
	* exemplo parâmetro: olá em diversas línguas.
	* exemplo de retorno: funções max e raw_input()
	* funções void
	* variáveis locais e globais
		- parâmetros são variáveis locais
	* funções podem chamar outras funções e podem ser chamadas por outras funções
	* excelente para quebrar um grande problema em vários problemas menores
		- dividir para conquistar
	* exercícios: lista funções Jefferson

LISTAS
	* vetores (diferenças)
	* coleção com vários valores em uma única variável
	* valores são identificados por índices
	* elementos em uma lista não precisam ser do mesmo tipo
	* listas podem conter outras listas (simular matrizes)
	* criando uma lista
		- vazia: l = []
		- vazia com função: l = list()
		- inicializada = l = ['teste', 4, 5.4]
	* adicionando elementos
		- append
	* acessando (olhando dentro da lista)
		- usando o operador [], colocando o índice da lista dentro
		- os índices iniciam em zero
		- ex: l = [5, 2, 6], l[1] == 2
	* tamanho de uma lista
		- função len()
	* operações com listas
		- concatenação +
		- repetição *
		- está ou não está (in, not in)
		- parte de uma lista (slicing, pedaços)
			. l = [0, 1, 2, 3, 4, 5, 6]
			. l[2:5] = [2, 3, 4]
			. l[4:] = [4, 5, 6]
			. l[:4] = [0, 1, 2, 3]
			. l[:] = l
	* podemos acessar/mudar um único elemento da lista, usando []
		- dá pra alterar por pedaços também (slices)
		- assim, dá pra inserir elementos no meio da lista, ou remover
		- remoção pouco legível. 
			. usar função del() passando o elemento ou fatia da lista que se quer remover
	* objetos e referências
		- função id
		- operador is
		- escalares são os mesmos se tem os mesmos valores.
		- listas não. listas são conjuntos de escalares.
		- aliasing (apelidos, ponteiros)
		- se queremos uma nova lista que é uma cópia, sem alterar, precisamos clonar a lista
			. melhor maneira é com slice
	* funções modificadoras (passagem de lista por referência)
	* funções para lista
		- da lista
			. append(valor)
			. insert(indice, valor)
			. pop(indice = len(l)-1)
			. sort
			. reverse
			. index(item)
			. count(item)
			. remove(item)
		- do python
			. len(lista)
			. max(lista)
			. min(lista)
			. sum(lista)
	* matrizes
		- listas aninhadas
		- podemos usar [] aninhados
		- para percorrer, usamos laços aninhados

STRINGS
	* uma string é uma sequência de caracteres
	* em Python, declaramos strings literais entre aspas simples ou duplas
	* uma string que contém um número ainda é uma string
		- podemos converter usando a função int ou float
	* operador +: concatenação
		- juntar, emendar
	* exemplos
	* em geral, lemos string e convertemos pro tipo que queremos
	* olhando dentro de uma string
		- uma string pode ser vista como uma lista de caracteres
		- é possível acessar qualquer caractere
		- como em uma lista, basta usar o índice
		- função len funciona perfeitamente
	* ASCII
		- função ord
	* percorrendo strings
		- while (imitando um for do C)
		- for (percorre letra por letra)
		- in também usado pra saber se um caractere está na string
	* parte de uma string (slicing, pedaços)
		- s = "Monty Python"
		- s[0:4] = "Mont"
		- s[6:7] = "P"
		- s[6:20] = "Python"
		- s[:2] = "Mo"
		- s[8:] = "thon"
		- s[:] = "Monty Python"
	* comparação
		- ordem lexicográfica
		- uso de ==, > e <
	* funções de string (string library)
		- retornam uma nova string (não modificam a original)
		- funções de string:
			. lower
			. upper
			. split
			. find
			. replace
			. lstrip, rstrip, strip (como o trim)
			. startswith
			. join
			. entre muitas outras
		- funções do Python
			. list
	* strings no Python são imutáveis
		- não podemos fazer algo do tipo:
			palavra = "Hello"
			palavra[0] = "A"
		- podemos burlar usando algo como nova = "A"+palavra[1:]
























